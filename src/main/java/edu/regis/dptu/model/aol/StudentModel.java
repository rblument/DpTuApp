/*
 * DPTu: Dynamic Programming Tutor
 * 
 *  (C) Johanna & Richard Blumenthal, All rights reserved
 * 
 *  Unauthorized use, duplication or distribution without the authors'
 *  permission is strictly prohibited.
 * 
 *  Unless required by applicable law or agreed to in writing, this
 *  software is distributed on an "AS IS" basis without warranties
 *  or conditions of any kind, either expressed or implied.
 */
package edu.regis.dptu.model.aol;

import edu.regis.dptu.model.*;
import edu.regis.dptu.dao.*;
import edu.regis.dptu.err.NonRecoverableException;
import static edu.regis.dptu.model.Model.DEFAULT_ID;
import edu.regis.dptu.model.ScaffoldLevel;
import edu.regis.dptu.util.XmlMgr;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer; 
import javax.xml.transform.TransformerFactory; 
import javax.xml.transform.dom.DOMSource; 
import javax.xml.transform.stream.StreamResult; 
import org.w3c.dom.Document; 
import org.w3c.dom.Element; 
import org.w3c.dom.NodeList;

/**
 * Captures the current assessment for each learning outcome in a course, as 
 * well as, all tutoring sessions in which the student participated.
 * 
 * @author rickb
 */
public class StudentModel extends Model {
    /**
     * Convenience reference to the user id (email) of the student associated
     * with this student model.
     */
    private String userId;
    
    /**
     * The assessments of outcomes for the student associated with this model.
     * The key is the id of the knowledge component in the associated assessment.
     */
    private HashMap<Integer, Assessment> assessments;
    
    /**
     * The current scaffolding being used to support the student.
     */
    private ScaffoldLevel scaffoldLevel = ScaffoldLevel.EXTREME;
    
    /**
     * A task object for verifying outcomes
     */
    Task task;
    
    /**
     * An XML object for interacting with the XML Manager
     */
    XmlMgr xml;
    
    /**
     * Instantiate this student model with default information.
     */
    public StudentModel() {
        super(DEFAULT_ID);
        
        assessments = new HashMap<>();
        
        xml = XmlMgr.instance();
        
        task = new Task();
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }
    
    public void addAssessment(int knowledgeComponentId, Assessment assessment) {
        assessments.put(knowledgeComponentId, assessment);
    }

    /**
     * Return whether this student has an assessment for the given outcome.
     * 
     * @param outcome
     * @return true if the student has an assessment for the given outcome.
     */
    public boolean containsAssessment(int knowledgeComponentId) {
        return assessments.containsKey(knowledgeComponentId);
    }
    
    /**
     * Return the student assessment, if any, for the given outcome.
     * 
     * @param outcome the Outcome being accessed
     * 
     * @return an Assessment of the student.
     */
    public Assessment findAssessment(int knowledgeComponentId) {
        return assessments.get(knowledgeComponentId);
    }
    
    /**
     * Return the current scaffolding level being used to support the student.
     * 
     * @return 
     */
    public ScaffoldLevel getScaffoldLevel() {
        return scaffoldLevel;
    }

    public void setScaffoldLevel(ScaffoldLevel scaffoldLevel) {
        this.scaffoldLevel = scaffoldLevel;
    }
    
    /**
     * Opens an XML file to write new KnowledgeComponent information to it if
     * necessary
     * 
     * @param id - the id generated by the database
     * @param outcome - the specification of what the student initialized 
     * @param title - the formal title of the outcome the student completed
     * @param component - the KnowledgeComponent being written
     * @param courseId - the id associated with the course
     * @param unitId - the id associated with the course unit
     * @param taskId - the id associated with the specific task
     * @param stepId - the id associated with the specific step
     */
    public void writeToXML(int id, String outcome, String title, KnowledgeComponent component, 
            int courseId, int unitId, int taskId, int stepId) {
       // Find the instance of the file, convert it to a string to open a new
       // file for appending purposes
       String filename = "Course_" + id + ".xml";
       File originalFile = xml.findFile(filename);
       String file = originalFile.toString();
       try {
            
            
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); 
            DocumentBuilder builder = factory.newDocumentBuilder(); 
  
            // Create a new Document 
            Document document = builder.parse(new File(file));
            
            // Gets the first doc element to append a KnowledgeComponent
            Element root = document.getDocumentElement();
            
            Element knowledgeComponent = document.createElement("KnowledgeComponent");
            
             // Set attributes for all the KnowledgeComponent stats
            knowledgeComponent.setAttribute("id", Integer.toString(id));
            knowledgeComponent.setAttribute("title", title + " Successfully Completed");
            knowledgeComponent.setAttribute("bloomLevel", component.getBloomLevel().toString());
            knowledgeComponent.setAttribute("focus", "Tutor");
            knowledgeComponent.setAttribute("pedagogy", component.getPedagogy().toString());
            
            // Small description of what the student has accomplished
            Element description = document.createElement("Description");
            description.appendChild(document.createTextNode("Student has successfully initialized the " + outcome));
            knowledgeComponent.appendChild(description);
            
            // Set attributes for the ExercisingLocation field
            Element exercisingLocation = document.createElement("ExercisingLocation");
            exercisingLocation.setAttribute("course", Integer.toString(courseId));
            exercisingLocation.setAttribute("unit", Integer.toString(unitId));
            exercisingLocation.setAttribute("task", Integer.toString(taskId));
            exercisingLocation.setAttribute("step", Integer.toString(stepId));
            knowledgeComponent.appendChild(exercisingLocation);
            
            root.appendChild(knowledgeComponent);
            
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
           
            DOMSource source = new DOMSource(document);
           
            StreamResult result = new StreamResult(new File(file));
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.transform(source, result);
            
            // Testing to make sure method is being invoked
            //System.out.println("File saved!");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Basic setters for information related to the KnowledgeComponent
     * 
     * @param id - the KnowledgeComponent ID
     * @param title - the title of the KnowledgeComponent
     * @param courseId - the id associated with the course
     * @param unitId - the id associated with the course unit
     * @param taskId - the id associated with the specific task
     * @param stepId - the id associated with the specific step
     * @return a KnowledgeComponent object with all the necessary information
     */
    public KnowledgeComponent componentValues(int id, String title, int courseId, 
            int unitId, int taskId, int stepId) {
        ArrayList<ExercisingLocation> locations = new ArrayList<>();
        ExercisingLocation location = new ExercisingLocation();
        
        // Testing for creating a component, can be updated in the future
        location.setCourseId(courseId);
        location.setUnitId(unitId);
        location.setTaskId(taskId);
        location.setStepId(stepId);
        locations.add(location);
        
        // Creates a KnowledgeComponent and sets its values
        KnowledgeComponent component = new KnowledgeComponent(id);
        component.setTitle(title);
        component.setBloomLevel(BloomLevel.APPLICATION);
        component.setPedagogy(TaskSelectionKind.FIXED_SEQUENCE);
        component.setGranularity(OutcomeGranularity.KNOWLEDGE_COMPONENT);
        component.setExercisingLocations(locations);
        component.setIsDomainFocus(false);
        
        
        return component;
    }
    
    /**
     * Tests if the student has successfully initialized the table
     * 
     * @param s1 - the first string of the LCS problem
     * @param s2 - the second string of the LCS problem
     * @return true if initialized, false if not
     */
    public boolean tableInitialized(String s1, String s2) {
        return task.checkTableSteps(s1, s2);
    }
    
    /**
     * Tests if the student has successfully initialized the table's size
     * 
     * @param s1 - the first string of the LCS problem
     * @param s2 - the second string of the LCS problem
     * @return true if initialized, false if not
     */
    public boolean sizeInitialized(String s1, String s2) {
        return task.checkSize(s1, s2);
    }
    
    /**
     * Tests if the student has successfully initialized the table's columns
     * and rows
     * 
     * @param s1 - the first string of the LCS problem
     * @param s2 - the second string of the LCS problem
     * @return true if initialized, false if not
     */
    public boolean colRowInitialized(String s1, String s2) {
        return task.checkValues(s1, s2);
    }
    
    /**
     * Tests if the student has successfully initialized the table's first
     * column
     * 
     * @param s1 - the first string of the LCS problem
     * @param s2 - the second string of the LCS problem
     * @return true if initialized, false if not
     */
    public boolean firstColInitialized(String s1, String s2) {
        return task.checkFirstCol(s1, s2);
    }
    
    /**
     * Compiles all of the initialization tests then create KnowledgeComponents
     * if necessary
     * 
     * @param s1 - the first string of the LCS problem
     * @param s2 - the second string of the LCS problem
     * @param id - the id generated by the database
     * @param courseId - the specific id for the course
     * @param unitId - the id for the course's unit
     * @param taskId - the id for the specific task
     * @param stepId - the id for the specific step
     */
    public void createComponents(String s1, String s2, int id, int courseId, 
            int unitId, int taskId, int stepId) {
        KnowledgeComponent tableTask, sizeTask, colRowTask, firstColTask;
        Assessment tableAssess, sizeAssess, colRowAssess, firstColAssess;

        
        if (tableInitialized(s1, s2)) {
            tableTask = componentValues(id, "Table Initialization", courseId, 
                    unitId, taskId, stepId);
            tableAssess = new Assessment(tableTask, AssessmentLevel.COMPLETED);
            addAssessment(id, tableAssess);
            writeToXML(id, "table", "Table Initialization", tableTask, courseId, unitId, 
                    taskId, stepId);
        }
        
        if (sizeInitialized(s1, s2)) {
            sizeTask = componentValues(id, "Size Initialization", courseId, 
                    unitId, taskId, stepId);
            sizeAssess = new Assessment(sizeTask, AssessmentLevel.COMPLETED);
            addAssessment(id, sizeAssess);
            writeToXML(id, "size of the table", "Size Initialization", sizeTask, 
                    courseId, unitId, taskId, stepId);
        }
        
        if (colRowInitialized(s1, s2)) {
            colRowTask = componentValues(id, "Grid Initialization", courseId, 
                    unitId, taskId, stepId);
            colRowAssess = new Assessment(colRowTask, AssessmentLevel.COMPLETED);
            addAssessment(id, colRowAssess);
            writeToXML(id, "columns & rows", "Grid Initialization", colRowTask, 
                    courseId, unitId, taskId, stepId);
        }
        
        if (firstColInitialized(s1, s2)) {
            firstColTask = componentValues(id, "First Column Initialization", courseId, 
                    unitId, taskId, stepId);
            firstColAssess = new Assessment(firstColTask, AssessmentLevel.COMPLETED);
            addAssessment(id, firstColAssess);
            writeToXML(id, "first column", "First Column Initialization", firstColTask, 
                    courseId, unitId, taskId, stepId);
        }
    }
    
    /**
     * Retrieves all KnowledgeComponents in the Course XML file
     * 
     * @param parent - the XML DOM element parent
     * @return an ArrayList containing all KnowledgeComponents
     */
    public ArrayList<KnowledgeComponent> learningOutcome(Element parent) 
        throws NonRecoverableException {
        ArrayList<KnowledgeComponent> components = new ArrayList<>();
        
        NodeList node = parent.getElementsByTagName("KnowledgeComponent");
        
        for (int i = 0; i < node.getLength(); i++) {
            components.add(retrieveComponent((Element) node.item(i)));
        }
        
        return components;
    }
    
    /**
     * Extracts individual KnowledgeComponents to add to the ArrayList in
     * learningOutcome
     * 
     * @param element - the XML DOM element
     * @return a singular KnowledgeComponent
     * @throws NonRecoverableException 
     */
    private KnowledgeComponent retrieveComponent(Element element) throws NonRecoverableException {
        KnowledgeComponent outcome = new KnowledgeComponent(XmlMgr.getIntAttribute(element, "id"));
        BloomLevel bloom = null;
        
        outcome.setTitle(XmlMgr.getAttribute(element, "title"));
        
        // Determine BloomLevel based on what the KnowledgeComponent reads
        switch (XmlMgr.getAttribute(element, "bloomLevel")) {
            case "Knowledge":
                bloom = BloomLevel.KNOWLEDGE;
                break;
            case "Comprehension":
                bloom = BloomLevel.COMPREHENSION;
                break;
            case "Application":
                bloom = BloomLevel.APPLICATION;
                break;
            case "Analysis":
                bloom = BloomLevel.ANALYSIS;
                break;
            case "Synthesis":
                bloom = BloomLevel.SYNTHESIS;
                break;
            default:
                bloom = BloomLevel.EVALUATION;
                break;
        }
        
        outcome.setBloomLevel(bloom);
         
        if (XmlMgr.getAttribute(element, "focus").equals("Tutor")) {
           outcome.setIsDomainFocus(false); // teaching the tutor/GUI itself
        } else {
           outcome.setIsDomainFocus(true);  // teaching SHA-256 domain
        }
        
        ArrayList<ExercisingLocation> locations = new ArrayList<>();
        NodeList nodes = element.getElementsByTagName("ExercisingLocations");
        
        // Iterate through each node to create an ExercisingLocation node and
        // add it to the ArrayList
        for (int i = 0; i < nodes.getLength(); i++) {
           ExercisingLocation location = new ExercisingLocation();

           location.setCourseId(XmlMgr.getIntAttribute(element, "course"));
           location.setUnitId(XmlMgr.getIntAttribute(element, "unit"));
           location.setTaskId(XmlMgr.getIntAttribute(element, "task"));
           location.setStepId(XmlMgr.getIntAttribute(element, "step"));
           
           locations.add(location);
        }
        
        outcome.setExercisingLocations(locations);
        
        return outcome;
    }
}
